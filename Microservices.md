[toc]

### [概述](https://martinfowler.com/articles/microservices.html)

- 简而言之，微服务架构风格是一种将单个应用开发为一个小型服务套件一部分的方法，每个服务运行在它自己的进程中，通过轻量机制进行沟通，比如HTTP，RPC。这些服务围绕业务能力进行构建并通过全自动化的部署机制进行独立部署。极少对这些服务进行集中管理，因为这些服务很可能用不同的语言编写并使用不同的数据存储技术。

- 要开始解释微服务风格，将其与单体风格进行比较很有用：单体应用程序会作为一个独立的单元进行构建。企业应用程序通常由三个主要部分构建：客户端用户界面（由在用户计算机上的浏览器中运行的HTML页面和javascript组成）和数据库（由插入通用（通常是关系型）数据库管理系统中的许多表组成）和服务器端应用程序。 服务器端应用程序将处理HTTP请求，执行逻辑，从数据库中检索和更新数据，以及选择并填充要发送到浏览器的HTML视图。 这个服务器端应用程序就是一个单体，一个单一的逻辑可执行文件。 对系统的任何更改都涉及构建和部署新版本的服务器端应用程序。

- 这样的单体服务是构建此类系统的很自然的方法，处理一个请求的所有逻辑都在一个进程中运行，这样你可以用编程语言的基本特性将应用分成类、函数、名称空间等等，可以在开发人员的电脑上运行和测试应用程序，并使用部署管道来确保对更改进行了正确的测试并将其部署到生产中，可以通过负载均衡运行许多实例来水平的伸缩这个单体应用。

- 单体应用可以说是成功的，但越来越多的人对它们感到沮丧，尤其是随着越来越多的应用程序部署到云上。变更捆绑在一起：对应用程序的一小部分进行更改，就需要重建和部署整个单体。随着时间推移，通常很难保持良好的模块化结构，使得仅保留影响该模块中一个模块的更改变得更加困难，这种扩展就要求扩展整个应用程序，而不是部分应用程序，这就需要更多地资源。

  - 单体应用 VS 微服务应用

    ![](img/micro_service1.png)

- 以上这些挫败感导致了微服务架构风格的出现：将应用程序构建为服务套件。除了服务可独立部署和可扩展之外，每个服务还提供了牢固的模块边界，甚至允许用不同的编程语言编写不同的服务，这些服务也可以由不同的团队管理。

- 微服务风格并不是新颖的或创新的，它的根源至少可以追溯到Unix的设计原理。 但是确实没有足够的人会考虑微服务架构，如果使用微服务架构，许多软件开发会更好。

### 微服务架构的特征

#### 通过服务进行组件化

- 自从我们涉足软件行业以来，人们就一直渴望通过将组件组装在一起来构建系统，就像我们在现实世界中看到的那样。在过去的几十年里，我们已经看到了作为大多数语言平台一部分的大型公共库的巨大进步。 
- 当谈到组件时，我们会遇到如何定义组件的难题。我们的定义是，一个组件是一个软件单元，它是可独立替换和升级的。 
- 微服务架构将使用库，但是它们将自己的软件组件化的主要方式是分解为服务，我们将库定义为组件，它们可以被链接到程序中，也可以通过内存中的函数调用来进行调用。而服务是进程外的组件 ，它们通过web service的请求或者远程过程调用(rpc)的机制进行通信。这与很多面向对象程序中的服务对象相比是不同的概念。
- 将服务作为组件(而不是库)的一个主要原因是服务是可独立部署的。 如果应用程序在单个进程中包含多个库，那么对任何单个组件的更改导致必须重新部署整个应用程序，但是如果应用程序被分解为多个服务 ，单个服务更改只需重新部署修改的服务。但这也不是绝对的，某些修改会改变服务接口从而导致一些服务之间的协调问题，但是一个好的微服务架构的目标是通过服务契约中的内聚服务边界和演化机制来最小化这些问题
- 使用服务作为组件的另一个结果是一个更显式的组件接口。 大多数语言都没有良好的机制来定义[Publicshed Interface](https://martinfowler.com/bliki/PublishedInterface.html)，通常只有文档和规则才能防止客户破坏组件的封装，从而导致组件之间过于紧密的耦合。通过使用显式远程调用机制，服务可以更容易地避免这种情况。 
- 使用这样的服务确实有缺点。远程调用比进程内调用的开销更大，因此远程api需要是粗粒度的，通常用起来更笨拙。如果需要更改组件之间的责任分配，那么当跨越进程边界时，这样的改变就很难实现。（意思是单体应用中，将某个行为从A移动到B相对简单，而微服务中，将某个行为从A服务移动到B服务中，相对来说成本更大，更困难）
-  近似的，我们可以观察到服务映射到运行时进程，但这只是一种大致的描述。一个服务是可以包含多个始终一起开发和部署的进程，这样的一种应用进程和数据库是被这个服务所独有的。

#### 围绕业务能力进行组织

- 在将大型应用程序拆分为多个部分时，管理层通常侧重于技术层，包括UI团队、服务器端逻辑团队和数据库团队。 当团队按照这些线分隔时，即使是小小的改变也会导致跨团队的项目沟通，一个聪明的团队通常会对其进行优化，减少这种情况的发生，将逻辑强制放到他们都能够访问的应用程序中就可以了。 换言之，逻辑无处不在。这是一个使用[Conway's Law](http://www.melconway.com/Home/Committees_Paper.html)的例子。

  > Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.
  >
  > -- Melvin Conway, 1968
  >
  > 任何设计一个系统的组织，将会生成一种design，这种design的结构就是这个组织通信结构的副本。
  >
  > 如下图，单体应用中，UI专家、中间件专家、DBA各司其职，应用Conway's Law之后，某个服务可能同时涉及UI、中间件、DB
  >
  > ![](img/micro_service2.png)

- 微服务的划分方法有点不同，它会将服务按照业务能力进行组织。这种服务采用该业务领域的软件实现，包括用户界面、持久化存储和任何外部协作。 因此，团队是一个包括开发所需要的全部技能的跨职能团队，包括用户体验、数据库和项目管理。  

  ![](img/micro_service3.png)

- 跨功能团队负责构建和操作每个产品，每个产品会被分割成多个通过消息总线通信的单个服务。 
- 大型单体应用程序也可以围绕业务功能进行模块化，尽管这种情况并不常见。当然，我们鼓励大型团队按照业务线划分来构建单体应用程序。我们在这里看到的主要问题是，它们往往围绕着太多的上下文进行组织。如果一个单体跨越了许多模块的边界，那么对于团队中的成员来说，就很难适应这种短期组织。此外，我们发现模块化还需要很好的规则来执行。服务组件所需要的更显式的分离使得保持团队边界清晰更加容易。 

#### 产品而不是项目

- 我们看到的大多数应用程序开发工作都使用项目模型 ：目标是交付一些软件，然后去考虑完成这些软件。完成后，软件被移交给维护组织，建立软件的项目团队被解散。 
- 微服务的支持者倾向于避免这种模型，而倾向于团队应该在产品的整个生命周期中拥有它。这方面的一个常见灵感来自Amazon的["you build, you run it"](https://queue.acm.org/detail.cfm?id=1142065)的概念，即开发团队对生产中的软件承担全部责任，这使开发人员每天都要接触到他们的软件在生产中的行为，并增加了与用户的联系，因为他们至少要承担一些支持工作。 
- 产品思维，与业务能力挂钩。与其将软件视为一组待完成的功能，还不如将其视为一种持续的关系，即软件如何帮助其用户增强业务能力。 
- 没有理由不能将同样的方法用于单体应用程序，但是服务的更小粒度可以更容易的加强服务开发人员与其用户之间的个人关系。 

#### 智能端点和哑管道 

- 在不同进程之间建立通信架构时，我们看到许多产品和方法都强调在沟通机制本身中加入重要的智慧，这方面的一个很好的例子是企业服务总线(Enterprise Service Bus)，ESB产品通常包括用于消息路由、编排、转换和应用业务规则的成熟工具。 

- 微服务则赞成另一种方法：智能端点和哑管道。微服务构建的应用程序旨在尽可能的解耦和内聚，它们有自己的领域逻辑，更多地充当经典Unix意义上的过滤器：接收请求，应用适当地逻辑并生成响应，它们使用简单的`RESTish`协议进行编排，而不是通过中心工具使用复杂的协议，如`WS-Choreography`或`BPEL`或`orchestration`。  

- 最常用的两种协议是带资源API的HTTP请求-响应协议和轻量级消息传递协议(例如`protocol buffers`)。最好的表述是 

  > Be of the web, not behind the web
  >
  
- 微服务团队使用万维网(在很大程度上是Unix)所建立的原则和协议，对于开发人员或操作人员来说，只需很少的工作就可以缓存经常使用的资源。
- 常用的第二种方法是通过轻量级消息总线进行消息传递，选择的基础设施通常是哑的(哑充当消息路由器)——简单的实现如RabbitMQ或ZeroMQ，只提供可靠的异步通信机制——这种智能也存在于端点之上，它们会在服务中生成并消费消息。 
- 在一个单体风格的应用程序中，组件在进程中执行，它们之间的通信是通过方法调用或函数调用进行。**将一个单体服务改变成微服务的最大问题在于改变通信模式**。从内存中的方法调用到RPC的转换会导致不正常的通信，这不会很好地执行。相反，需要用粗粒度的方法替换细粒度的通信。 （进程内的调用粒度越细越好）

####  去中心化治理

- 中心化治理的后果之一是单一技术平台的标准化趋势。经验表明，这种做法是行不通的，不是每个问题都是钉子，也不是每个解决方法都是锤子。我们更喜欢使用正确的工具来完成工作，虽然单体风格的应用程序可以在一定程度上利用不同的语言，但这并不常见。
- 将单体组件拆分为服务时，我们可以选择性的构建每个服务。你想使用Node.js来建立一个简单的报表页面？就去做吧。用c++做一个接近实时的组件？没有问题。你想换一个不同风格的数据库，更好地适合一个组件的读取行为？我们有重建它的技术。
- 当然，你可以做一些事情，并不意味着你应该做——但是以这种方式划分系统意味着你可以选择。
- 构建微服务的团队也倾向于使用不同的标准。他们不喜欢使用写在纸上的一套定义好的标准，他们更喜欢开发有用的工具，让其他开发人员可以使用这些工具来解决他们所面临的类似问题。这些工具通常从实现中获得并与更广泛的组共享，有时，但不完全使用内部开放源码模型。现在git和github已经成为事实上的版本控制系统的选择，开源实践在内部变得越来越普遍。
- Netflix就是遵循这一理念的一个很好的例子。将有用的(最重要的是)经过实战测试的代码作为库共享，可以鼓励其他开发人员以类似的方式解决类似的问题，但也为必要时选择不同的方法敞开了大门。共享库倾向于关注数据存储、进程间通信以及基础设施自动化等常见问题。
- 对于微服务社区来说，开销尤其没有吸引力。这并不是说社区不重视服务契约。恰恰相反，因为它们的数量往往更多。只是他们在寻找管理这些契约的不同方法。[Tolerant Reader](https://martinfowler.com/bliki/TolerantReader.html)和[Consumer-Driven Contracts](https://martinfowler.com/articles/consumerDrivenContracts.html)等模式经常应用于微服务。这些援助服务协议在独立演变。作为构建的一部分，执行消费者驱动的契约可以增强信心，并提供关于服务是否在运行的快速反馈。事实上，我们知道澳大利亚的一个团队使用[Consumer-Driven Contracts](https://martinfowler.com/articles/consumerDrivenContracts.html)驱动新服务的构建。他们使用简单的工具来定义服务的契约。甚至在为新服务编写代码之前，这就成为自动构建的一部分。然后，服务被构建到满足合同的程度——这是在构建新软件时避免“YAGNI(You Aren't Going To Need It)”困境的优雅方法。这些技术和围绕它们成长起来的工具，通过减少服务之间的时间耦合，限制了对中央契约管理的需求。
- 或许去中心化治理的巅峰是Amazon推广的build it / run it精神。团队要对他们构建的软件的所有方面负责，包括24/7的运行软件。这种级别的责任下放显然不是一种规范，但我们确实看到越来越多的公司将责任推给开发团队。Netflix是另一家采用这种理念的公司。每天晚上3点被寻呼机吵醒，这无疑是在编写代码时关注质量的强大动力。这些想法离传统的集中式治理模型要多远就有多远。

#### 去中心化数据管理

- 去中心化的数据管理有许多不同的方式，在最抽象的层次上，它意味着世界的概念模型在系统之间是不同的。在跨大型企业进行集成时，这是一个常见的问题，客户的销售视图将与支持视图不同。有些在销售视图中称为客户的东西可能根本不会出现在支持视图中。

- 这个问题在应用程序之间很常见，但也可能在应用程序内部发生，特别是当应用程序被分解成多个组件时。思考这个问题的一种有用的方式是[Bounded Context](https://martinfowler.com/bliki/BoundedContext.html)的Domain-Driven Design（简称DDD）方式。DDD将复杂的领域划分为多个bounded context，并映射出它们之间的关系。这个过程对于单体架构和微服务架构都很有用。但是服务和上下文边界之间有一种自然的相关性，这有助于澄清问题，正如我们在业务功能一节中所描述的，要加强这种分离。

- 与概念模型的去中心化决策一样，微服务也有去中心化数据存储的决策。单体应用程序喜欢使用单个逻辑数据库来存储持久化数据，而企业通常更喜欢跨一系列应用程序使用单一数据库，许多这些决定都是由厂商的商业模式驱动的。微服务倾向于让每个服务管理自己的数据库，可以是相同数据库的不同实例，也可以是完全不同的数据库，这叫做[Polyglot Persistence](https://martinfowler.com/bliki/PolyglotPersistence.html)，也可以在一个单体应用程序中使用Polyglot Persistence，但它在微服务中使用得更频繁。

  ![](img\micro_service4.png)

- 跨微服务分散数据责任对管理更新有影响，处理更新的常用方法是使用事务来保证更新多个资源时的一致性。这种方法经常在单体应用程序中使用。

- 使用这样的事务有助于保持一致性，但增加了显著的耦合，这在多个服务之间是有问题的，众所周知，分布式事务很难实现，因此，微服务体系结构强调服务之间的无事务协调，一致性可能只是最终的一致性，并且通过补偿操作来处理问题。

- 选择以这种方式管理不一致性对许多开发团队来说是一个新的挑战，但是它通常符合业务实践。通常，业务会选择一定程度的不一致性，以便快速响应需求，同时使用某种逆转过程来处理错误。只要修正错误的成本低于在更大的一致性下失去业务的成本，这种交换是值得的。

#### 基础设施自动化

- 基础设施自动化技术在过去几年中有了巨大的发展——尤其是云和AWS的发展降低了构建、部署和运行微服务的操作复杂性。

- 使用微服务构建的许多产品或系统都是由具有[Continuous Delivery](https://martinfowler.com/bliki/ContinuousDelivery.html)(持续交付)和[Continuous Integration](https://martinfowler.com/articles/continuousIntegration.html)(持续集成)丰富经验的团队构建的。以这种方式构建软件的团队广泛使用了基础设施自动化技术。这在下面所示的构建管道中进行了说明。

  ![](img\micro_service5.png)

- 因为这不是一篇关于持续交付的文章，所以我们在这里只关注几个关键特性。我们希望尽可能多地相信我们的软件在工作，所以我们运行许多自动化测试。将工作软件“向上”推进管道意味着我们将自动部署到每个新环境。

- 一个独立的应用程序将被构建、测试和通过这些环境推送。事实证明，一旦您为一个庞然大物投资了自动化生产路径，那么部署更多应用程序似乎就不再那么可怕了。请记住，CD的目标之一就是让部署变得乏味，所以不管它是一个应用程序还是三个应用程序，只要它仍然乏味就没关系。

- 我们看到团队使用广泛的基础设施自动化的另一个领域是在生产环境中管理微服务时。我们在上面断言，只要部署是无聊的，那么在monoliths和microservices之间就没有太大的区别，这与此相反，它们的操作环境可能截然不同

  ![](img\micro_service6.png)

#### 容错设计

- 将服务作为组件使用的一个后果是，应用程序需要被设计成能够容忍服务的故障。任何服务调用都可能由于供应方不可用而失败，客户端必须尽可能优雅地响应此请求。与单体风格的应用程序相比，这是一个缺点，因为它增加了处理它的复杂性。其结果是，微服务团队不断地反思服务失败是如何影响用户体验的。Netflix的[Simian Army](https://github.com/Netflix/SimianArmy)在工作日内通过监测服务甚至数据中心的故障来测试应用程序的弹性和监控能力。
- 生产中的这种自动化测试足以让大多数操作组在休假一周之前感到战栗。这并不是说单一的架构风格不能实现复杂的监控设置——只是在我们的经验中不太常见而已。
- 由于服务随时可能发生故障，因此能够快速检测故障并在可能的情况下自动恢复服务非常重要。
- 微服务应用程序非常重视对应用程序的实时监视，检查体系结构元素(数据库每秒接收多少请求)和业务相关指标(例如每分钟接收多少订单)。语义监视可以提供出错的早期预警系统，从而促使开发团队进行跟踪和调查。
- 这对于微服务体系结构尤其重要，因为对编排和事件协作的微服务偏好会导致紧急行为。虽然许多专家都称赞偶然涌现的价值，但事实是，突发行为有时可能是一件坏事。监控对于快速发现不良的紧急行为并加以修复至关重要。
- 单体风格的应用程序可以像微型服务一样透明——事实上，它们应该是透明的。区别在于，您绝对需要知道在不同进程中运行的服务何时断开连接。如果库在同一进程中，这种透明性就不太可能有用。
- 微服务团队希望看到针对每个单独服务的复杂监视和日志设置，比如显示启动/关闭状态的仪表板以及各种操作和业务相关指标。详细的断路器状态，当前吞吐量和延迟的等等，我们经常在野外遇到。

#### 演进式设计

- 微服务实践者通常具有进化设计背景，他们将服务分解视为进一步的工具，使应用程序开发人员能够控制其应用程序中的更改，而不会减慢更改的速度。变更控制并不一定意味着变更减少——有了正确的态度和工具，您就可以对软件进行频繁、快速和良好控制的变更。
- 当您试图将一个软件系统分解为多个组件时，您面临着如何分割这些组件的决策——我们决定分割应用程序的原则是什么?组件的关键属性是独立替换和可升级的概念——这意味着我们要寻找可以在不影响其协作者的情况下重写组件的点。实际上，许多微服务组织更进一步，明确地希望许多服务被废弃，而不是在更长的时期内发展。
- 卫报网站是应用程序的一个很好的例子，它被设计和构建为一个单体，但一直在朝着微服务的方向发展。这个庞然大物仍然是网站的核心，但他们更喜欢通过构建使用庞然大物API的微服务来增加新特性。这种方法对于本质上是临时的特性特别方便，比如处理体育赛事的专门页面。这样的部分可以使用快速开发语言快速地组合在一起，并在事件结束后删除。我们在金融机构看到过类似的做法。
- 这种对可替换性的强调是模块化设计的一个更普遍原则的特殊情况，这个原则是通过更改[14]的模式来驱动模块化。您希望将同时更改的内容保存在同一个模块中。系统中很少变化的部分应该位于与那些正在经历大量变动的服务不同的服务中。如果您发现自己重复地将两个服务一起更改，那就表明应该合并它们。
- 将组件放入服务中可以提供更细粒度的发布计划。对于一个单体风格的应用程序，任何更改都需要对整个应用程序进行完整的构建和部署。然而，对于microservices，您只需要重新部署您修改过的服务。这可以简化并加速发布过程。缺点是您必须担心对某个服务的更改会损害其使用者。传统的集成方法是尝试使用版本控制来处理这个问题，但是在微服务领域中，首选方法是只将版本控制作为最后的手段。我们可以通过将服务设计为尽可能容忍其供应服务的更改，来避免大量的版本控制。

### others

#### 一个微服务有多大

- 尽管“微服务”已经成为这种架构风格的一个流行名称，但它的名称不幸地导致了对服务规模的关注，以及关于什么是“微”的争论。在我们与微服务从业者的对话中，我们看到了一系列规模不等的服务。据报道，最大尺寸遵循亚马逊的两个比萨饼团队的概念（即整个团队可以吃两个比萨饼），意思是不超过十二个人。在较小的规模上，我们看到一个六人团队可以提供六种服务。
- 这就引出了这样一个问题：在这个规模范围内是否存在足够大的差异，以至于“每十二个人服务”和“每个人服务”的规模不应该被集中在一个微服务的标签下。目前，我们认为最好将它们组合在一起，但当我们进一步探索这种风格时，我们当然有可能改变主意。

#### 微服务与SOA

- 当我们谈论微服务时，一个常见的问题是这是否只是我们十年前看到的面向服务的体系结构（SOA）。 这一点是有价值的，因为微服务风格与某些SOA倡导者所支持的风格非常相似。 但是，问题在于SOA意味着太多不同的事物，并且在大多数情况下，我们遇到一种称为“ SOA”的东西，这与我们在此描述的风格有很大不同，通常是因为着眼于过去的ESB。 集成单片应用程序。
- 特别是，我们已经看到了许多面向服务的拙劣实现，从倾向于将复杂性隐藏在ESB中，到花费了数百万美元且没有任何价值的失败的计划，到集中化的治理模型抑制了变化， 有时很难看清这些问题。
- 当然，微服务社区中使用的许多技术都是开发人员在大型组织中集成服务的经验中获得的。 [Tolerant Reader](https://martinfowler.com/bliki/TolerantReader.html)就是一个例子。使用web的努力做出了贡献，使用简单的协议是从这些经验中衍生出来的另一种方法--一种远离中心标准的反应，中心标准已经达到了一种复杂的程度 （每当您需要一个本体来管理您的本体时，您就知道自己陷入了严重的麻烦。）
- SOA的这种普遍表现导致一些微服务倡导者完全拒绝了SOA标签，尽管其他人认为微服务是SOA的一种形式，也许面向服务是正确的。无论哪种方式，SOA都意味着如此不同的事实，这一事实意味着拥有一个更清晰地定义这种体系结构风格的术语是有价值的

#### 很多的语言、很多的选择

- JVM作为平台的发展只是在公共平台中混合语言的最新例子。几十年来，为了利用更高级别的抽象，开发更高级别的语言是一种常见的做法。就像在一个更低的层次上写性能敏感的代码一样。然而，许多单体并不需要这种级别的性能优化，DSL和更高级别的抽象也不常见(令我们沮丧的是)。相反，单体应用程序通常是单一的语言，其趋势是限制使用的技术的数量。

#### 经过实战检验的标准和强制执行的标准

- 微服务团队倾向于避开企业架构组制定的那种严格的强制标准，但乐于使用甚至鼓励使用诸如HTTP、ATOM和其他微格式等开放标准，这有点像二分法。
- 关键的区别在于标准是如何制定和执行的。IETF等组织所管理的标准只有在更广泛的世界中有几个实际的实现时才会成为标准，而且这些标准通常是由成功的开源项目发展而来。
- 这些标准与企业界的许多标准截然不同，企业界的标准通常是由最近很少有编程经验或受供应商影响很大的团队开发的。

#### 让做正确的事情变得容易

- 我们发现，持续交付和部署带来的自动化增加的一个副作用是创建了有用的工具来帮助开发人员和操作人员。用于创建工件、管理代码库、支持简单服务或用于添加标准监视和日志记录的工具现在非常常见。网络上最好的例子可能是Netflix的一套开源工具，但也有包括Dropwizard在内的我们广泛使用的其他工具。

#### 熔断器和生产准备代码

- [熔断器](https://martinfowler.com/bliki/CircuitBreaker.html)出现在 [Release It！](https://www.amazon.com/gp/product/B00A32NXZO?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B00A32NXZO)中，其他的比如Bulkhead和Timeout模式。同时实现这些模式，在构建通信应用程序时非常重要。[Netflix blog entry](http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html) 很好地解释了它们的应用。

#### 被认为有害的同步调用

- 每当服务之间有大量同步调用时，会遇到宕机带来的成倍影响。简单地说，就是当系统的宕机时间变成单个组件宕机时间的乘积时。面临一个选择，采用异步调用还是管理宕机时间。www.guardian.co.uk在新平台上实现了一个简单的规则——每个用户请求一次同步调用，而在Netflix，他们的平台API重新设计已将异步性内置到API结构中。

#### 微服务的权衡

- 许多开发团队已经发现微服务体系结构风格是一种优于单片体系结构的方法。但其他团队发现，这是一个降低生产率的负担。像任何架构风格一样，微服务带来了成本和收益。要做出明智的选择，你必须理解这些并将它们应用到你的特定环境中。