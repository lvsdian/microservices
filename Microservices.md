[toc]

### [概述](https://martinfowler.com/articles/microservices.html)

- 简而言之，微服务架构风格是一种将单个应用开发为一个小型服务套件的方法，每个服务运行在它自己的进程中，通过轻量机制进行沟通，比如HTTP，RPC。这些服务围绕业务能力进行构建并通过全自动化的部署机器进行独立部署。极少对这些服务进行集中管理，因为这些服务很可能用不同的语言编写并使用不同的数据存储技术。

- 要开始解释微服务风格，将其与整体风格进行比较很有用：整体应用程序作为单个单元进行构建。 企业应用程序通常由三个主要部分构建：客户端用户界面（由在用户计算机上的浏览器中运行的HTML页面和javascript组成）和数据库（由插入通用（通常是关系型）数据库管理系统中的许多表组成）和服务器端应用程序。 服务器端应用程序将处理HTTP请求，执行逻辑，从数据库中检索和更新数据，以及选择并填充要发送到浏览器的HTML视图。 这个服务器端应用程序就是一个整体，一个单一的逻辑可执行文件。 对系统的任何更改都涉及构建和部署新版本的服务器端应用程序。

- 这样的整体服务是构建此类系统的很自然的方法，处理请求的所有逻辑都在一个流程中运行，所以你可以用编程语言的基本特性将应用分成类、函数、名称空间等等，可以在开发人员的电脑上运行和测试应用程序，并使用部署管道来确保对更改进行了正确的测试并将其部署到生产中，可以通过在负载均衡运行许多实例来水平缩放整体。

- 整体应用可以说是成功的，但越来越多的人对它们感到沮丧，尤其是随着越来越多的应用程序部署到云中。变更捆绑在一起：对应用程序的一小部分进行更改，就需要重建和部署整个整体。随着时间推移，通常很难保持良好的模块化结构，使得仅保留影响该模块中一个模块的更改变得更加困难，扩展要求扩展整个应用程序，而不是部分应用程序，这就需要更多地资源。

  - 整体应用 VS 微服务应用

    ![](img/micro_service1.png)

- 以上这些挫败感导致了微服务架构的风格：将应用程序构建为服务套件。除了服务可独立部署和可扩展之外，每个服务还提供了牢固的模块边界，甚至允许用不同的编程语言编写不同的服务，这些服务也可以由不同的团队管理。

- 微服务风格并不是新颖的或创新的，它的根源至少可以追溯到Unix的设计原理。 但是确实没有足够的人会考虑微服务架构，如果使用微服务架构，许多软件开发会更好。

### 微服务架构的特征

#### 通过服务进行组件化

- 自从我们从事软件行业以来，就一直希望通过将组件连接在一起来构建系统，我们看待事物是在物理世界中创造的，在过去的几十年里，我们已经看到了作为大多数语言平台一部分的大型公共库汇编的巨大进步。 
- 当谈到组件时，我们会遇到如何定义组件的难题。我们的定义是，一个组件是一个软件单元，它是可独立替换和升级的。 
- 微服务架构将使用库，但是它们将自己的软件组件化的主要方式是分解为服务，我们将库定义为链接到程序中的组件，并使用内存中的函数调用进行调用， 而服务是与web服务请求等机制通信的进程外组件 ，或远程过程调用。
- 将服务作为组件(而不是库)的一个主要原因是服务是可独立部署的。 如果应用程序在单个进程中包含多个库，那么对任何单个组件的更改导致必须重新部署整个应用程序，但是如果应用程序被分解为多个服务 ，单个服务更改只需重新部署修改的服务。但这也不是绝对的，某些修改会改变服务接口从而导致一些服务之间的协调问题，但是一个好的微服务架构的目标是通过服务契约中的内聚服务边界和演化机制来最小化这些问题
- 使用服务作为组件的另一个结果是一个更显式的组件接口。 大多数语言都没有良好的机制来定义[Publicshed Interface](https://martinfowler.com/bliki/PublishedInterface.html)，通常只有文档和规则才能防止客户破坏组件的封装，从而导致组件之间过于紧密的耦合。通过使用显式远程调用机制，服务可以更容易地避免这种情况。 
- 使用这样的服务确实有缺点。远程调用比进程内调用的开销更大，因此远程api需要是粗粒度的，这通常使用起来更麻烦。如果需要更改组件之间的责任分配，那么当跨越进程边界时，这样的改变就很难实现。
-  在第一个近似中，我们可以观察到服务映射到运行时进程，但这只是第一个近似。一个服务可能包含多个始终一起开发和部署的进程，例如一个应用程序进程和一个仅由该服务使用的数据库。

#### 围绕业务能力进行组织

- 在将大型应用程序拆分为多个部分时，管理层通常侧重于技术层，包括UI团队、服务器端逻辑团队和数据库团队。 当团队按照这些线分开时，即使是简单的更改也会导致跨团队的项目花费时间和预算，聪明的团队会充分利用这一点，选择两害相权取其轻：只要将逻辑强制放到他们能够访问的任何应用程序中就可以了。 换言之，逻辑无处不在。这是一个使用[Conway's Law](http://www.melconway.com/Home/Committees_Paper.html)的例子。

  > Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.
  >
  > -- Melvin Conway, 1968
  ![](img/micro_service2.png)

- 微服务的划分方法是不同的，是按照业务能力划分为服务。此类服务采用该业务领域的广泛软件实现，包括用户界面、持久化存储和任何外部协作。 因此，团队是跨职能的，包括开发所需的全部技能:用户体验、数据库和项目管理。  

  ![](img/micro_service3.png)

- 跨功能团队负责构建和操作每个产品，每个产品被分割成许多通过消息总线通信的单个服务。 
- 大型整体应用程序也总是可以围绕业务功能进行模块化，尽管这种情况并不常见。当然，我们鼓励团队按照业务线划分构建大型整体应用程序。我们在这里看到的主要问题是，它们往往围绕着太多的上下文进行组织。如果一个整体跨越了许多模块的边界，就很难将它们放入他们的短期内存中。此外，我们看到模块化的代码需要大量的规则来执行。服务组件所需要的更显式的分离使得保持团队边界清晰更加容易。 

#### 产品而不是项目

- 我们看到的大多数应用程序开发工作都使用项目模型 ：目标是交付一些软件，然后被认为是完成的。完成后，软件被移交给维护组织，建立软件的项目团队被解散。 
- 微服务的支持者倾向于避免这种模型，而倾向于团队应该在产品的整个生命周期中拥有它。这方面的一个常见灵感来自Amazon的["you build, you run it"](https://queue.acm.org/detail.cfm?id=1142065)的概念，即开发团队对生产中的软件承担全部责任，这使开发人员每天都要接触到他们的软件在生产中的行为，并增加了与用户的联系，因为他们至少要承担一些支持负担。 
- 产品思维，与业务能力相联系。与其将软件视为一组待完成的功能，还不如将其视为一种持续的关系，即软件如何帮助其用户增强业务能力。 
- 没有理由不能将同样的方法用于整体应用程序，但是服务的更小粒度可以更容易地创建服务开发人员与其用户之间的个人关系。 

#### 智能端点和哑管道 

- 在不同进程之间建立通信架构时，我们看到许多产品和方法都强调在沟通机制本身中加入重要的智慧，这方面的一个很好的例子是企业服务总线(Enterprise Service Bus)，ESB产品通常包括用于消息路由、编排、转换和应用业务规则的成熟工具。 

- 微服务则赞成另一种方法：智能端点和哑管道。微服务构建的应用程序旨在尽可能地解耦和内聚，它们有自己的域逻辑，更多地充当经典Unix意义上的过滤器：接收请求，应用适当地逻辑并生成响应，它们使用简单的`RESTish`协议进行编排，而不是通过中心工具使用复杂的协议，如`WS-Choreography`或`BPEL`或`orchestration`。  

- 最常用的两种协议是带资源API的HTTP请求-响应协议和轻量级消息传递协议(例如`protocol buffers`)。最好的表述是 

  > Be of the web, not behind the web
  >
  > -- [Ian Robinson](https://www.amazon.com/gp/product/0596805829?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596805829)![img](https://www.assoc-amazon.com/e/ir?t=martinfowlerc-20&l=as2&o=1&a=0321601912)

- 微服务团队使用万维网(在很大程度上是Unix)所建立的原则和协议。 对于开发人员或操作人员来说，只需很少的工作就可以缓存经常使用的资源。
- 常用的第二种方法是通过轻量级消息总线进行消息传递。选择的基础设施通常是哑的(哑充当消息路由器)——简单的实现如RabbitMQ或ZeroMQ，不要提供可靠的异步结构 ——智慧在生产和消费的端点处;也就是服务。 
- 在一个整体风格的应用程序中，组件在进程中执行，它们之间的通信是通过方法调用或函数调用进行的。将一个整体服务变成微服务的最大问题在于改变通信模式。从内存中的方法调用到RPC的简单转换会导致不正常的通信，这不会很好地执行。相反，需要用粗粒度的方法替换细粒度的通信。 